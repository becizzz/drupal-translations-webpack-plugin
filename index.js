/**
 * DrupalTranslationsWebpackPlugin
 *
 * (c) 2018 by Jan Hug
 * Released under the MIT license.
 *
 */

const ConstDependency = require('webpack/lib/dependencies/ConstDependency')
const NullFactory = require('webpack/lib/NullFactory')

const PLUGIN = 'ExtractDrupalTranslationsPlugin'

class ExtractDrupalTranslationsPlugin {
  constructor (options) {
    options = options || {}
    this.output = options.output || 'drupalTranslations.js'
  }

  /**
   * @param {Compiler} compiler 
   */
  apply (compiler) {
    var functionCalls = []
    var output = this.output

    // Tap into the compilation hook and announce we're coming.
    compiler.hooks.compilation.tap(PLUGIN, (compilation) => {
      compilation.dependencyFactories.set(ConstDependency, new NullFactory())
      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template())
    })

    // Now tap again into someting.
    compiler.hooks.normalModuleFactory.tap(PLUGIN, (factory) => {

      // More tapping, now in the parser, for javascript files!
      factory.hooks.parser.for('javascript/auto').tap(PLUGIN, (parser) => {

        // And now tap into calling the Drupal.t functions.
        parser.hooks.call.for('Drupal.t').tap(PLUGIN, (expression) => {

          // Let's evaluate the first argument of the Drupal.t call: Drupal.t(X, __, __)
          const translationKey = parser.evaluateExpression(expression.arguments[0])

          // If this is non-existing or not a string, return.
          if (!translationKey || !translationKey.string || typeof translationKey.string !== 'string') {
            return false
          }

          // Find out where the function call is located.
          const start = expression.range[0]
          const end = expression.range[1]

          // Slice out the whole call from the source file.
          const functionCall = parser.state.current._source._value.slice(start, end)

          functionCalls.push(functionCall)

          return false
        })
      })
    })

    // Tap into the emit hook. Happens when all compilation is over and files are written to disk.
    compiler.hooks.emit.tapAsync(PLUGIN, (compilation, callback) => {
      // Remove all newlines from the function calls. Then join the array with new lines and two spaces.
      const functionCallsString = functionCalls.map(f => {
        return f.replace(/(\r\n\t|\n|\r\t)/gm, '')
      }).join('\n  ')

      const content = fileOutput(functionCallsString)

      // Attach our translations file to the compilation assets.
      compilation.assets[output] = {
        source: () => {
          return content
        },
        size: () => {
          return content.length
        }
      }

      // Done!
      callback()
    })
  }
}

/**
 * Generate the contents of the file with all function calls for Drupal.
 *
 * @param {String} content All the function calls to Drupal.t and Drupal.formatPlural
 */
function fileOutput (content) {
  return `
// This file is generated by the webpack plugin ${PLUGIN}.
// It is required for Drupal to figure out which translations are needed,
// since its regex is unable to process minified webpack code.

function ${PLUGIN} () {
  ${content}
}
`
}

module.exports = ExtractDrupalTranslationsPlugin
